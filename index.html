<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
  <title>Shake Rhythm — Pro UI</title>
  <style>
    :root{
      color-scheme: dark;
      --bg0:#070a10;
      --bg1:#0b0f1a;
      --fg:#e7edf7;
      --muted:rgba(231,237,247,.72);
      --line:rgba(255,255,255,.10);
      --blue:#2f81f7;
      --cyan:#2dd4ff;
      --green:#2ea043;
      --red:#f85149;
      --amber:#ffcc66;
    }
    *{ box-sizing:border-box; }
    body{
      margin:0; min-height:100vh;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, "Hiragino Kaku Gothic ProN","Noto Sans JP", sans-serif;
      background: radial-gradient(1400px 900px at 50% 12%, rgba(47,129,247,.18), transparent 60%),
                  radial-gradient(1200px 900px at 10% 80%, rgba(45,212,255,.10), transparent 55%),
                  linear-gradient(180deg, var(--bg0), var(--bg1));
      color: var(--fg);
      overflow:hidden;
    }

    /* App shell */
    .app{
      position:relative;
      width:100vw; height:100vh;
      display:flex;
      flex-direction:column;
    }
    .topbar{
      height:58px;
      display:flex;
      align-items:center;
      padding:0 14px;
      gap:12px;
      border-bottom:1px solid var(--line);
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      backdrop-filter: blur(10px);
    }
    .brand{
      display:flex; align-items:center; gap:10px;
      font-weight:800; letter-spacing:.2px;
    }
    .logo{
      width:26px;height:26px;border-radius:8px;
      background: radial-gradient(circle at 30% 30%, rgba(45,212,255,.95), rgba(47,129,247,.85) 40%, rgba(0,0,0,.0) 70%),
                  linear-gradient(135deg, rgba(255,255,255,.18), rgba(255,255,255,0));
      border:1px solid rgba(255,255,255,.20);
      box-shadow: 0 10px 30px rgba(47,129,247,.25);
    }
    .spacer{ flex:1; }

    .pill{
      display:inline-flex; align-items:center; gap:8px;
      padding:8px 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.18);
      color: var(--muted);
      font-size:12px;
      white-space:nowrap;
    }
    .mono{ font-variant-numeric: tabular-nums; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }

    .btn{
      appearance:none;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color: var(--fg);
      padding:10px 12px;
      border-radius:12px;
      font-weight:700;
      letter-spacing:.2px;
      cursor:pointer;
      transition: transform .06s ease, background .12s ease, border-color .12s ease;
    }
    .btn:active{ transform: translateY(1px); }
    .btn.primary{
      background: linear-gradient(180deg, rgba(47,129,247,.95), rgba(47,129,247,.78));
      color:#06101c;
      border-color: rgba(47,129,247,.70);
      box-shadow: 0 12px 30px rgba(47,129,247,.22);
    }
    .btn.ghost{
      background: rgba(255,255,255,.04);
    }

    .main{
      position:relative;
      flex:1;
      display:grid;
      place-items:center;
      padding:10px;
    }

    canvas{
      width:min(95vw, 560px);
      height:min(82vh, 920px);
      border-radius:22px;
      border:1px solid rgba(255,255,255,.12);
      background:
        radial-gradient(1200px 900px at 50% 25%, rgba(47,129,247,.12), transparent 60%),
        linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      box-shadow: 0 18px 70px rgba(0,0,0,.55);
      display:block;
      touch-action:none;
    }

    /* Overlays */
    .overlay{
      position:absolute;
      inset:0;
      display:grid;
      place-items:center;
      pointer-events:none;
    }
    .panel{
      width:min(92vw, 520px);
      border-radius:22px;
      border:1px solid rgba(255,255,255,.14);
      background: linear-gradient(180deg, rgba(255,255,255,.10), rgba(0,0,0,.22));
      box-shadow: 0 22px 70px rgba(0,0,0,.55);
      padding:18px 16px;
      pointer-events:auto;
      backdrop-filter: blur(14px);
    }
    .panel h1{
      margin:0 0 8px 0;
      font-size:22px;
      letter-spacing:.2px;
    }
    .panel p{
      margin:0 0 14px 0;
      color: var(--muted);
      line-height:1.5;
      font-size:13px;
    }
    .grid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
      margin:10px 0 12px;
    }
    .card{
      border-radius:16px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.18);
      padding:12px 12px;
    }
    label{ display:block; font-size:12px; color:var(--muted); margin-bottom:6px; }
    select, input[type="range"]{
      width:100%;
    }
    select{
      border-radius:12px;
      padding:10px 10px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color: var(--fg);
      outline:none;
      font-weight:700;
    }
    input[type="range"]{
      accent-color: var(--blue);
    }
    .row{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
      justify-content:flex-end;
      margin-top:10px;
    }

    .toast{
      position:absolute;
      left:50%;
      transform:translateX(-50%);
      bottom:14px;
      padding:10px 12px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.35);
      color: rgba(231,237,247,.9);
      font-size:12px;
      pointer-events:none;
      opacity:0;
      transition: opacity .18s ease;
      backdrop-filter: blur(10px);
    }
    .toast.show{ opacity:1; }

    .hidden{ display:none !important; }
  </style>
</head>

<body>
<div class="app">
  <div class="topbar">
    <div class="brand"><div class="logo"></div>Shake Rhythm</div>
    <div class="pill">Input: <b>縦 / 横 / 斜め</b> 対応</div>
    <div class="pill">Mode: <span class="mono" id="modeText">TAP</span></div>
    <div class="spacer"></div>
    <button class="btn ghost" id="btnPerm">モーション許可</button>
    <button class="btn ghost" id="btnPause">一時停止</button>
    <button class="btn ghost" id="btnRestart">リスタート</button>
  </div>

  <div class="main">
    <canvas id="game" width="560" height="920"></canvas>

    <!-- Start panel -->
    <div class="overlay" id="ovStart">
      <div class="panel">
        <h1>Shake Rhythm</h1>
        <p>
          スマホを<b>軽く振る</b>だけでノーツ判定。縦振り・横振りどちらでもOK。<br/>
          iPhoneは「モーション許可」→「START」の順で。
        </p>

        <div class="grid">
          <div class="card">
            <label>難易度</label>
            <select id="difficulty">
              <option value="easy">EASY（ゆっくり）</option>
              <option value="normal" selected>NORMAL（標準）</option>
              <option value="hard">HARD（速い）</option>
            </select>
          </div>

          <div class="card">
            <label>感度（高いほど軽く反応）</label>
            <input id="sens" type="range" min="1.10" max="2.10" step="0.01" value="1.70"/>
            <div class="pill" style="margin-top:10px;">SENS: <span class="mono" id="sensText">1.70</span></div>
          </div>

          <div class="card">
            <label>SE音量</label>
            <input id="seVol" type="range" min="0" max="1" step="0.01" value="0.65"/>
            <div class="pill" style="margin-top:10px;">SE: <span class="mono" id="seText">0.65</span></div>
          </div>

          <div class="card">
            <label>BGM音量（簡易トラック）</label>
            <input id="bgmVol" type="range" min="0" max="1" step="0.01" value="0.55"/>
            <div class="pill" style="margin-top:10px;">BGM: <span class="mono" id="bgmText">0.55</span></div>
          </div>
        </div>

        <div class="row">
          <button class="btn ghost" id="btnHow">操作確認</button>
          <button class="btn primary" id="btnStart">START</button>
        </div>
      </div>
    </div>

    <!-- Result panel -->
    <div class="overlay hidden" id="ovResult">
      <div class="panel">
        <h1>RESULT</h1>
        <p id="resultSummary"></p>
        <div class="grid">
          <div class="card"><label>SCORE</label><div class="mono" id="rScore" style="font-size:20px;font-weight:900;">0</div></div>
          <div class="card"><label>MAX COMBO</label><div class="mono" id="rMaxCombo" style="font-size:20px;font-weight:900;">0</div></div>
          <div class="card"><label>PERFECT</label><div class="mono" id="rP">0</div></div>
          <div class="card"><label>GREAT / GOOD / MISS</label><div class="mono" id="rGOM">0 / 0 / 0</div></div>
        </div>
        <div class="row">
          <button class="btn ghost" id="btnBack">戻る</button>
          <button class="btn primary" id="btnAgain">もう一回</button>
        </div>
      </div>
    </div>

    <div class="toast" id="toast"></div>
  </div>
</div>

<script>
(() => {
  // ---------- DOM ----------
  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");
  const ovStart = document.getElementById("ovStart");
  const ovResult = document.getElementById("ovResult");
  const toast = document.getElementById("toast");
  const modeText = document.getElementById("modeText");

  const elDiff = document.getElementById("difficulty");
  const elSens = document.getElementById("sens");
  const elSensText = document.getElementById("sensText");
  const elSeVol = document.getElementById("seVol");
  const elSeText = document.getElementById("seText");
  const elBgmVol = document.getElementById("bgmVol");
  const elBgmText = document.getElementById("bgmText");

  // topbar buttons
  const btnPerm = document.getElementById("btnPerm");
  const btnPause = document.getElementById("btnPause");
  const btnRestart = document.getElementById("btnRestart");

  // start panel buttons
  const btnStart = document.getElementById("btnStart");
  const btnHow = document.getElementById("btnHow");

  // result panel
  const btnBack = document.getElementById("btnBack");
  const btnAgain = document.getElementById("btnAgain");
  const resultSummary = document.getElementById("resultSummary");
  const rScore = document.getElementById("rScore");
  const rMaxCombo = document.getElementById("rMaxCombo");
  const rP = document.getElementById("rP");
  const rGOM = document.getElementById("rGOM");

  // ---------- UI wiring ----------
  function showToast(msg){
    toast.textContent = msg;
    toast.classList.add("show");
    clearTimeout(showToast._t);
    showToast._t = setTimeout(() => toast.classList.remove("show"), 1200);
  }
  function fmt2(x){ return (Math.round(x*100)/100).toFixed(2); }

  elSens.addEventListener("input", ()=>{ elSensText.textContent = fmt2(parseFloat(elSens.value)); });
  elSeVol.addEventListener("input", ()=>{ elSeText.textContent = fmt2(parseFloat(elSeVol.value)); });
  elBgmVol.addEventListener("input", ()=>{ elBgmText.textContent = fmt2(parseFloat(elBgmVol.value)); });

  btnHow.addEventListener("click", ()=>{
    showToast("操作：ノーツが判定ラインに来た瞬間に、軽く振る（縦/横どちらでもOK）");
  });

  // ---------- Game constants ----------
  const W = canvas.width, H = canvas.height;
  const laneX = W * 0.5;
  const judgeY = H * 0.79;

  const DIFF = {
    easy:   { bpm: 92,  lengthBeats: 64, spawnJitter: 0.09, overlapRate: 0.22, noteSpeed: 420, inputThreshold: 6.6 },
    normal: { bpm: 112, lengthBeats: 80, spawnJitter: 0.07, overlapRate: 0.34, noteSpeed: 520, inputThreshold: 5.9 },
    hard:   { bpm: 134, lengthBeats: 96, spawnJitter: 0.06, overlapRate: 0.46, noteSpeed: 650, inputThreshold: 5.2 },
  };

  const WINDOWS = [
    { name:"PERFECT", dt:0.060, pts:100, key:"perfect" },
    { name:"GREAT",   dt:0.100, pts: 70, key:"great"   },
    { name:"GOOD",    dt:0.140, pts: 40, key:"good"    },
  ];

  // ---------- Audio (BGM + SE) ----------
  let audioCtx = null;
  let master = null, bgmBus = null, seBus = null;
  let bgmStarted = false;
  let songStartAt = 0; // audioCtx time
  let schedulerId = null;

  // simple synth nodes reused
  function ensureAudio(){
    if (audioCtx) return;
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();

    master = audioCtx.createGain();
    bgmBus = audioCtx.createGain();
    seBus = audioCtx.createGain();

    bgmBus.connect(master);
    seBus.connect(master);
    master.connect(audioCtx.destination);

    master.gain.value = 0.9;
  }

  function setVolumes(){
    if (!audioCtx) return;
    seBus.gain.value = Math.max(0, Math.min(1, parseFloat(elSeVol.value)));
    bgmBus.gain.value = Math.max(0, Math.min(1, parseFloat(elBgmVol.value)));
  }

  function playSE(type){
    if (!audioCtx) return;
    const t0 = audioCtx.currentTime;

    // small click + tone by type
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    const f = (type==="PERFECT") ? 1400 : (type==="GREAT") ? 1100 : (type==="GOOD") ? 850 : 220;
    const dur = (type==="MISS") ? 0.08 : 0.05;
    const amp = (type==="MISS") ? 0.11 : 0.08;

    o.type = (type==="MISS") ? "sawtooth" : "square";
    o.frequency.setValueAtTime(f, t0);

    g.gain.setValueAtTime(amp, t0);
    g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);

    o.connect(g).connect(seBus);
    o.start(t0);
    o.stop(t0 + dur);
  }

  function kick(t){
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = "sine";
    o.frequency.setValueAtTime(120, t);
    o.frequency.exponentialRampToValueAtTime(50, t + 0.08);
    g.gain.setValueAtTime(0.9, t);
    g.gain.exponentialRampToValueAtTime(0.0001, t + 0.10);
    o.connect(g).connect(bgmBus);
    o.start(t);
    o.stop(t + 0.12);
  }

  function hat(t){
    const bufferSize = 2 * audioCtx.sampleRate;
    const noiseBuffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
    const out = noiseBuffer.getChannelData(0);
    for (let i=0; i<bufferSize; i++) out[i] = Math.random()*2-1;

    const noise = audioCtx.createBufferSource();
    noise.buffer = noiseBuffer;

    const bp = audioCtx.createBiquadFilter();
    bp.type = "highpass";
    bp.frequency.setValueAtTime(7000, t);

    const g = audioCtx.createGain();
    g.gain.setValueAtTime(0.20, t);
    g.gain.exponentialRampToValueAtTime(0.0001, t + 0.035);

    noise.connect(bp).connect(g).connect(bgmBus);
    noise.start(t);
    noise.stop(t + 0.04);
  }

  function bass(t, freq){
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    const lp = audioCtx.createBiquadFilter();
    lp.type = "lowpass";
    lp.frequency.setValueAtTime(550, t);

    o.type = "triangle";
    o.frequency.setValueAtTime(freq, t);

    g.gain.setValueAtTime(0.22, t);
    g.gain.exponentialRampToValueAtTime(0.0001, t + 0.16);

    o.connect(lp).connect(g).connect(bgmBus);
    o.start(t);
    o.stop(t + 0.18);
  }

  // audio scheduler (simple step sequencer)
  let seqStep = 0;
  function startBGM(bpm){
    ensureAudio();
    setVolumes();
    if (audioCtx.state === "suspended") audioCtx.resume();

    bgmStarted = true;
    seqStep = 0;
    const stepDur = 60 / bpm / 2; // 8th note
    songStartAt = audioCtx.currentTime + 0.08;

    const lookAhead = 0.10;
    const scheduleHorizon = 0.20;

    function schedule(){
      const now = audioCtx.currentTime;
      while (songStartAt + seqStep * stepDur < now + scheduleHorizon){
        const t = songStartAt + seqStep * stepDur;

        // Kick on 1,3 (every 4 steps in 8-step bar)
        if (seqStep % 8 === 0 || seqStep % 8 === 4) kick(t);

        // Hat every step, accent off-beat
        hat(t);

        // Bass pattern (simple)
        const barPos = seqStep % 16;
        if (barPos === 0) bass(t, 55);
        if (barPos === 6) bass(t, 62);
        if (barPos === 8) bass(t, 73);
        if (barPos === 14) bass(t, 62);

        seqStep++;
      }
      schedulerId = setTimeout(schedule, lookAhead * 1000);
    }
    schedule();
  }

  function stopBGM(){
    bgmStarted = false;
    if (schedulerId) { clearTimeout(schedulerId); schedulerId = null; }
  }

  // ---------- Input detection (axis-aware + peak) ----------
  let lastAx=0, lastAy=0, lastAz=0;
  let peak = 0;
  let peakDecayTimer = null;
  let lastInputMs = -999;

  const INPUT = {
    cooldownMs: 72,
    peakHoldMs: 70,
    noiseGate: 0.32,
    wX: 1.0, wY: 1.0, wZ: 0.70,
  };

  function updatePeak(val){
    peak = Math.max(peak, val);
    if (peakDecayTimer) return;
    peakDecayTimer = setTimeout(() => {
      peak *= 0.55;
      peakDecayTimer = null;
    }, INPUT.peakHoldMs);
  }

  function computeImpulse(acc){
    const ax = acc.x || 0, ay = acc.y || 0, az = acc.z || 0;
    const dx = Math.abs(ax - lastAx);
    const dy = Math.abs(ay - lastAy);
    const dz = Math.abs(az - lastAz);
    lastAx=ax; lastAy=ay; lastAz=az;

    const gdx = Math.max(0, dx - INPUT.noiseGate);
    const gdy = Math.max(0, dy - INPUT.noiseGate);
    const gdz = Math.max(0, dz - INPUT.noiseGate);

    const gain = parseFloat(elSens.value); // user control
    const impulse = (gdx*INPUT.wX + gdy*INPUT.wY + gdz*INPUT.wZ) * gain * 1.25;
    return impulse;
  }

  function tryInput(){
    const nowMs = performance.now();
    if ((nowMs - lastInputMs) < INPUT.cooldownMs) return false;
    lastInputMs = nowMs;
    return true;
  }

  // iOS permission
  async function requestMotionPermission(){
    try{
      if (typeof DeviceMotionEvent === "undefined"){
        showToast("この端末/ブラウザはDeviceMotionに非対応の可能性");
        return;
      }
      if (typeof DeviceMotionEvent.requestPermission === "function"){
        const res = await DeviceMotionEvent.requestPermission();
        if (res !== "granted"){
          showToast("モーション許可が拒否されました");
          return;
        }
      }
      window.addEventListener("devicemotion", onMotion, { passive:true });
      showToast("モーション入力を有効化しました");
    }catch(e){
      console.error(e);
      showToast("モーション許可に失敗しました");
    }
  }

  function onMotion(e){
    if (!state.running) return;
    const acc = e.accelerationIncludingGravity || e.acceleration;
    if (!acc) return;

    const impulse = computeImpulse(acc);
    updatePeak(impulse);

    const th = state.params.inputThreshold;
    if (peak > th && tryInput()){
      peak = 0; // consume
      judgeAt(getSongTimeSec());
      // haptics (Android)
      if (navigator.vibrate) navigator.vibrate(8);
    }
  }

  // Desktop fallback
  window.addEventListener("keydown", (e)=>{
    if (e.code === "Space"){
      e.preventDefault();
      if (!state.running) return;
      if (tryInput()) judgeAt(getSongTimeSec());
    }
  }, { passive:false });

  // Non-iOS auto attach
  if (typeof DeviceMotionEvent !== "undefined" && typeof DeviceMotionEvent.requestPermission !== "function"){
    window.addEventListener("devicemotion", onMotion, { passive:true });
  }

  btnPerm.addEventListener("click", requestMotionPermission);

  // ---------- Gameplay ----------
  const state = {
    running:false,
    paused:false,
    ended:false,
    params: DIFF.normal,
    // timing
    t0Perf: 0,
    // chart
    notes: [], // {t, judged, hit}
    // score
    score:0,
    combo:0,
    maxCombo:0,
    counts:{ perfect:0, great:0, good:0, miss:0 },
    // visuals
    hitRipples: [], // {x,y,r,life}
    particles: [],
    camShake: 0,
    lastFrame: 0,
  };

  function resetState(){
    state.score=0; state.combo=0; state.maxCombo=0;
    state.counts = { perfect:0, great:0, good:0, miss:0 };
    state.hitRipples.length = 0;
    state.particles.length = 0;
    state.camShake = 0;
    state.ended = false;

    // input reset
    lastAx=lastAy=lastAz=0;
    peak=0;
    lastInputMs=-999;
  }

  function buildChart(params){
    const beatSec = 60 / params.bpm;
    const arr = [];
    for (let i=0; i<params.lengthBeats; i++){
      const baseT = i * beatSec;

      arr.push(baseT);
      if (Math.random() < 0.35) arr.push(baseT + 0.5*beatSec);

      if (Math.random() < params.overlapRate){
        const extra = (Math.random() < 0.35) ? 2 : 1;
        for (let k=0; k<extra; k++){
          const jitter = (Math.random()*2 - 1) * params.spawnJitter * beatSec;
          arr.push(baseT + jitter);
        }
      }
    }
    arr.sort((a,b)=>a-b);

    const leadIn = 1.7;
    state.notes = arr.map(t => ({ t: t + leadIn, judged:false, hit:false }));
  }

  function startGame(){
    ensureAudio();
    setVolumes();

    state.params = DIFF[elDiff.value];
    resetState();
    buildChart(state.params);

    // start BGM and define time mapping from audio to gameplay
    stopBGM();
    startBGM(state.params.bpm);
    state.t0Perf = performance.now();
    state.running = true;
    state.paused = false;
    modeText.textContent = "TAP";

    ovStart.classList.add("hidden");
    ovResult.classList.add("hidden");
    showToast("READY");

    state.lastFrame = performance.now();
    requestAnimationFrame(loop);
  }

  function pauseToggle(){
    if (!state.running || state.ended) return;
    state.paused = !state.paused;

    if (state.paused){
      // pause audio context (suspend)
      if (audioCtx) audioCtx.suspend();
      showToast("PAUSE");
    } else {
      if (audioCtx) audioCtx.resume();
      showToast("RESUME");
      state.lastFrame = performance.now();
      requestAnimationFrame(loop);
    }
  }

  function restart(){
    stopGame(false);
    ovStart.classList.remove("hidden");
    showToast("設定を確認してSTART");
  }

  function stopGame(showResult=true){
    state.running = false;
    state.paused = false;
    stopBGM();

    if (audioCtx && audioCtx.state === "running") {
      // keep context alive; no hard stop needed
    }
    if (showResult) openResult();
  }

  function openResult(){
    state.ended = true;
    ovResult.classList.remove("hidden");

    rScore.textContent = String(state.score);
    rMaxCombo.textContent = String(state.maxCombo);
    rP.textContent = String(state.counts.perfect);
    rGOM.textContent = `${state.counts.great} / ${state.counts.good} / ${state.counts.miss}`;

    const total = state.counts.perfect + state.counts.great + state.counts.good + state.counts.miss;
    const acc = total ? Math.round((state.counts.perfect*1 + state.counts.great*0.7 + state.counts.good*0.4) / total * 1000)/10 : 0;
    resultSummary.textContent = `ACC: ${acc}%  |  総ノーツ: ${total}  |  難易度: ${elDiff.value.toUpperCase()}`;
  }

  btnStart.addEventListener("click", startGame);
  btnPause.addEventListener("click", pauseToggle);
  btnRestart.addEventListener("click", restart);
  btnBack.addEventListener("click", ()=>{ ovResult.classList.add("hidden"); ovStart.classList.remove("hidden"); });
  btnAgain.addEventListener("click", startGame);

  // ---------- Timing ----------
  function getSongTimeSec(){
    // Prefer audio time when available for better sync
    if (audioCtx && bgmStarted){
      return Math.max(0, audioCtx.currentTime - songStartAt);
    }
    return (performance.now() - state.t0Perf) / 1000;
  }

  // ---------- Judgement ----------
  function judgeAt(t){
    if (!state.running || state.paused) return;

    const goodWin = WINDOWS[WINDOWS.length-1].dt;

    // collect hittable notes in window
    const hitList = [];
    for (const n of state.notes){
      if (n.judged) continue;
      const dt = Math.abs(t - n.t);
      if (dt <= goodWin) hitList.push({ n, dt });
    }

    if (hitList.length === 0){
      // empty hit: small negative feedback (optional)
      playSE("MISS");
      spawnRipple(laneX, judgeY, "miss");
      state.camShake = Math.min(1, state.camShake + 0.12);
      return;
    }

    let bestGrade = null;

    for (const h of hitList){
      const { n, dt } = h;
      let grade = null;
      for (const w of WINDOWS){ if (dt <= w.dt){ grade = w; break; } }
      if (!grade) continue;

      n.judged = true;
      n.hit = true;

      state.score += grade.pts;
      state.combo += 1;
      state.maxCombo = Math.max(state.maxCombo, state.combo);
      state.counts[grade.key] += 1;

      if (!bestGrade || grade.pts > bestGrade.pts) bestGrade = grade;
    }

    if (bestGrade){
      playSE(bestGrade.name);
      spawnRipple(laneX, judgeY, bestGrade.name.toLowerCase());
      burstParticles(laneX, judgeY, bestGrade.name);
      state.camShake = Math.min(1, state.camShake + (bestGrade.name==="PERFECT" ? 0.20 : 0.12));
    }
  }

  function processMisses(t){
    const missAfter = WINDOWS[WINDOWS.length-1].dt;
    for (const n of state.notes){
      if (n.judged) continue;
      if (t - n.t > missAfter){
        n.judged = true;
        n.hit = false;
        state.counts.miss += 1;
        state.combo = 0;
        // mild visual for miss
        spawnRipple(laneX, judgeY, "miss");
      }
    }
  }

  // ---------- Visual FX ----------
  function spawnRipple(x,y,kind){
    state.hitRipples.push({ x,y,r:18, life:1, kind });
  }

  function burstParticles(x,y,grade){
    const n = (grade==="PERFECT") ? 22 : (grade==="GREAT") ? 16 : 10;
    for (let i=0;i<n;i++){
      const a = Math.random()*Math.PI*2;
      const s = (grade==="PERFECT") ? (2.6 + Math.random()*3.2) : (2.2 + Math.random()*2.6);
      state.particles.push({
        x,y,
        vx: Math.cos(a)*s,
        vy: Math.sin(a)*s - 1.2,
        life: 0.9 + Math.random()*0.5,
        size: 2 + Math.random()*2.4,
        grade
      });
    }
  }

  function lerp(a,b,t){ return a + (b-a)*t; }

  // ---------- Render ----------
  function draw(t, dt){
    const p = state.params;

    // camera shake
    const shake = state.camShake;
    state.camShake = Math.max(0, state.camShake - dt*1.8);

    const sx = (Math.random()*2-1) * 6 * shake;
    const sy = (Math.random()*2-1) * 6 * shake;

    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0,0,W,H);

    ctx.save();
    ctx.translate(sx, sy);

    // background particles
    ctx.globalAlpha = 0.9;
    // soft vignette
    const vg = ctx.createRadialGradient(W*0.5,H*0.2, 120, W*0.5,H*0.7, 520);
    vg.addColorStop(0, "rgba(47,129,247,0.10)");
    vg.addColorStop(1, "rgba(0,0,0,0.35)");
    ctx.fillStyle = vg;
    ctx.fillRect(0,0,W,H);

    // lane glow
    const laneW = 280;
    const laneX0 = (W-laneW)/2;
    const laneGrad = ctx.createLinearGradient(0,0,0,H);
    laneGrad.addColorStop(0, "rgba(255,255,255,0.06)");
    laneGrad.addColorStop(1, "rgba(0,0,0,0.18)");
    ctx.fillStyle = laneGrad;
    roundRect(ctx, laneX0, 70, laneW, H-140, 22);
    ctx.fill();

    // grid lines
    ctx.globalAlpha = 0.25;
    ctx.strokeStyle = "rgba(157,189,240,0.22)";
    for (let y=100; y<H; y+=64){
      ctx.beginPath();
      ctx.moveTo(laneX0+18, y);
      ctx.lineTo(laneX0+laneW-18, y);
      ctx.stroke();
    }
    ctx.globalAlpha = 1;

    // judge line and windows
    const pxGood = WINDOWS[2].dt * p.noteSpeed;
    const pxGreat = WINDOWS[1].dt * p.noteSpeed;
    const pxPerfect = WINDOWS[0].dt * p.noteSpeed;

    // window highlights
    ctx.save();
    ctx.globalAlpha = 0.10;
    ctx.fillStyle = "rgba(47,129,247,1)";
    ctx.fillRect(laneX0+18, judgeY - pxGood, laneW-36, pxGood*2);
    ctx.globalAlpha = 0.14;
    ctx.fillRect(laneX0+18, judgeY - pxGreat, laneW-36, pxGreat*2);
    ctx.globalAlpha = 0.18;
    ctx.fillRect(laneX0+18, judgeY - pxPerfect, laneW-36, pxPerfect*2);
    ctx.restore();

    // judge line
    ctx.save();
    ctx.lineWidth = 3;
    ctx.strokeStyle = "rgba(45,212,255,0.85)";
    ctx.shadowColor = "rgba(45,212,255,0.55)";
    ctx.shadowBlur = 14;
    ctx.beginPath();
    ctx.moveTo(laneX0+18, judgeY);
    ctx.lineTo(laneX0+laneW-18, judgeY);
    ctx.stroke();
    ctx.restore();

    // notes (stack overlaps)
    const visibleTop = -120, visibleBottom = H + 120;
    const stacks = [];
    const tol = 0.012;

    for (const n of state.notes){
      const y = noteY(n.t, t, p.noteSpeed);
      if (y < visibleTop || y > visibleBottom) continue;
      if (n.judged && y > judgeY + 22) continue;

      let found = false;
      for (const s of stacks){
        if (Math.abs(s.t - n.t) < tol){ s.items.push({n,y}); found = true; break; }
      }
      if (!found) stacks.push({ t:n.t, items:[{n,y}] });
    }

    for (const s of stacks){
      const items = s.items;
      items.sort((a,b)=>a.y-b.y);
      for (let i=0;i<items.length;i++){
        const { n, y } = items[i];
        const offset = (i - (items.length-1)/2) * 16;
        drawNote(laneX + offset, y, n);
      }
    }

    // ripples
    for (let i=state.hitRipples.length-1; i>=0; i--){
      const r = state.hitRipples[i];
      r.life -= dt*2.2;
      r.r += dt*260;
      if (r.life <= 0){ state.hitRipples.splice(i,1); continue; }

      const alpha = Math.max(0, r.life);
      let col = "rgba(45,212,255,";
      if (r.kind==="perfect") col = "rgba(45,212,255,";
      if (r.kind==="great") col = "rgba(47,129,247,";
      if (r.kind==="good") col = "rgba(255,204,102,";
      if (r.kind==="miss") col = "rgba(248,81,73,";

      ctx.save();
      ctx.globalAlpha = 1;
      ctx.lineWidth = 3;
      ctx.strokeStyle = col + (0.35*alpha) + ")";
      ctx.shadowColor = col + (0.55*alpha) + ")";
      ctx.shadowBlur = 18;
      ctx.beginPath();
      ctx.arc(r.x, r.y, r.r, 0, Math.PI*2);
      ctx.stroke();
      ctx.restore();
    }

    // particles
    for (let i=state.particles.length-1; i>=0; i--){
      const ptl = state.particles[i];
      ptl.life -= dt*1.5;
      if (ptl.life <= 0){ state.particles.splice(i,1); continue; }
      ptl.vy += 10*dt;
      ptl.x += ptl.vx * 60*dt;
      ptl.y += ptl.vy * 60*dt;

      const a = Math.max(0, Math.min(1, ptl.life));
      let c = "rgba(45,212,255,";
      if (ptl.grade==="GREAT") c = "rgba(47,129,247,";
      if (ptl.grade==="GOOD") c = "rgba(255,204,102,";
      ctx.fillStyle = c + (0.75*a) + ")";
      ctx.fillRect(ptl.x, ptl.y, ptl.size, ptl.size);
    }

    // HUD
    drawHUD(t);

    ctx.restore();
  }

  function roundRect(ctx, x, y, w, h, r){
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr,y);
    ctx.arcTo(x+w,y, x+w,y+h, rr);
    ctx.arcTo(x+w,y+h, x,y+h, rr);
    ctx.arcTo(x,y+h, x,y, rr);
    ctx.arcTo(x,y, x+w,y, rr);
    ctx.closePath();
  }

  function noteY(noteTime, t, speed){
    const dt = noteTime - t;
    return judgeY - dt * speed;
  }

  function drawNote(x,y,note){
    const r = 16;
    const base = note.judged ? (note.hit ? "good" : "miss") : "live";

    ctx.save();
    let fill = "rgba(231,237,247,0.88)";
    let ring = "rgba(45,212,255,0.70)";
    let glow = "rgba(45,212,255,0.55)";

    if (base==="good"){
      fill = "rgba(46,160,67,0.86)";
      ring = "rgba(46,160,67,0.95)";
      glow = "rgba(46,160,67,0.55)";
    } else if (base==="miss"){
      fill = "rgba(248,81,73,0.52)";
      ring = "rgba(248,81,73,0.60)";
      glow = "rgba(248,81,73,0.45)";
    }

    // body
    ctx.beginPath();
    ctx.fillStyle = fill;
    ctx.shadowColor = glow;
    ctx.shadowBlur = note.judged ? 8 : 16;
    ctx.arc(x, y, r, 0, Math.PI*2);
    ctx.fill();

    // ring
    if (!note.judged){
      ctx.beginPath();
      ctx.strokeStyle = ring;
      ctx.lineWidth = 2;
      ctx.shadowBlur = 18;
      ctx.arc(x, y, r-5, 0, Math.PI*2);
      ctx.stroke();
    }

    // pulse highlight
    if (!note.judged){
      const pulse = 0.5 + 0.5*Math.sin(performance.now()/120);
      ctx.beginPath();
      ctx.globalAlpha = 0.10 + 0.12*pulse;
      ctx.fillStyle = "rgba(255,255,255,1)";
      ctx.arc(x, y, r+6, 0, Math.PI*2);
      ctx.fill();
    }

    ctx.restore();
  }

  function drawHUD(t){
    const p = state.params;

    // Score/combo
    ctx.save();
    ctx.fillStyle = "rgba(231,237,247,0.92)";
    ctx.font = "800 22px system-ui, -apple-system, Segoe UI, Roboto, sans-serif";
    ctx.fillText(`SCORE  ${state.score}`, 18, 34);

    ctx.fillStyle = "rgba(231,237,247,0.72)";
    ctx.font = "700 15px system-ui, -apple-system, Segoe UI, Roboto, sans-serif";
    ctx.fillText(`COMBO  ${state.combo}   (MAX ${state.maxCombo})`, 18, 56);

    // judgement text
    // (lightweight: show last based on peak/threshold)
    // also show input meters
    const th = state.params.inputThreshold;
    ctx.fillStyle = "rgba(231,237,247,0.60)";
    ctx.font = "650 13px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
    ctx.fillText(`TH:${th.toFixed(1)}  PEAK:${peak.toFixed(2)}  SENS:${parseFloat(elSens.value).toFixed(2)}`, 18, H-20);

    // progress
    const last = state.notes[state.notes.length-1];
    const endT = last ? last.t : 0;
    const prog = endT ? Math.max(0, Math.min(1, t / (endT + 0.6))) : 0;
    const barW = 180, barH = 8;
    const bx = W - barW - 18, by = 22;
    ctx.fillStyle = "rgba(255,255,255,0.10)";
    ctx.fillRect(bx, by, barW, barH);
    ctx.fillStyle = "rgba(45,212,255,0.85)";
    ctx.fillRect(bx, by, barW*prog, barH);

    ctx.restore();
  }

  // ---------- Loop ----------
  function loop(){
    if (!state.running || state.paused) return;

    const now = performance.now();
    const dt = Math.min(0.05, (now - state.lastFrame) / 1000);
    state.lastFrame = now;

    const t = getSongTimeSec();
    processMisses(t);
    draw(t, dt);

    // end check
    const last = state.notes[state.notes.length-1];
    if (last && (t - last.t) > 1.1){
      stopGame(true);
      return;
    }

    requestAnimationFrame(loop);
  }

  // ---------- Start / Pause / Restart ----------
  btnPause.addEventListener("click", pauseToggle);
  btnRestart.addEventListener("click", restart);

  // ---------- Motion permission shortcut ----------
  btnPerm.addEventListener("click", requestMotionPermission);

  // Keep volumes live
  elSeVol.addEventListener("input", setVolumes);
  elBgmVol.addEventListener("input", setVolumes);

  // initial texts
  elSensText.textContent = fmt2(parseFloat(elSens.value));
  elSeText.textContent = fmt2(parseFloat(elSeVol.value));
  elBgmText.textContent = fmt2(parseFloat(elBgmVol.value));

  // expose minimal debug
  window.__ShakeRhythm = { startGame, pauseToggle, requestMotionPermission };

})();
</script>
</body>
</html>