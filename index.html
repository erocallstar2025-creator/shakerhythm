<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Shake Rhythm (Long Notes)</title>
  <style>
    :root { color-scheme: dark; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, "Hiragino Kaku Gothic ProN", "Noto Sans JP", sans-serif;
      background: #0b0f14;
      color: #e6edf3;
      display: flex;
      min-height: 100vh;
      flex-direction: column;
    }
    header {
      padding: 12px 14px;
      border-bottom: 1px solid rgba(255,255,255,0.08);
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
    }
    header .title { font-weight: 700; letter-spacing: 0.2px; }
    header .controls {
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
      margin-left: auto;
    }
    select, button {
      background: rgba(255,255,255,0.08);
      color: #e6edf3;
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 10px;
      padding: 10px 12px;
      font-size: 14px;
      outline: none;
    }
    button { cursor: pointer; }
    button.primary {
      background: #2f81f7;
      border-color: rgba(47,129,247,0.6);
      color: #07121f;
      font-weight: 700;
    }
    button.danger {
      background: rgba(248,81,73,0.15);
      border-color: rgba(248,81,73,0.4);
      color: #ffb4b0;
    }
    main { flex: 1; display: grid; place-items: center; padding: 10px; }
    canvas {
      width: min(94vw, 520px);
      height: min(78vh, 860px);
      background: radial-gradient(1200px 900px at 50% 20%, rgba(47,129,247,0.08), transparent 60%),
                  linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02));
      border: 1px solid rgba(255,255,255,0.10);
      border-radius: 16px;
      box-shadow: 0 12px 40px rgba(0,0,0,0.45);
      touch-action: none;
    }
    footer {
      padding: 10px 14px 14px;
      border-top: 1px solid rgba(255,255,255,0.08);
      font-size: 12px;
      color: rgba(230,237,243,0.75);
      line-height: 1.45;
    }
    .row { display: flex; gap: 12px; flex-wrap: wrap; align-items: center; }
    .pill {
      display: inline-flex; gap: 8px; align-items: center;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(0,0,0,0.18);
      padding: 8px 10px;
      border-radius: 999px;
      font-size: 12px;
      color: rgba(230,237,243,0.9);
    }
    .mono { font-variant-numeric: tabular-nums; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
  </style>
</head>

<body>
<header>
  <div class="title">Shake Rhythm — ロングノーツ対応</div>
  <div class="controls">
    <select id="difficulty">
      <option value="easy">EASY（ゆっくり）</option>
      <option value="normal" selected>NORMAL（標準）</option>
      <option value="hard">HARD（速い）</option>
    </select>
    <button id="motionPerm">モーション許可（iPhone用）</button>
    <button class="primary" id="start">START</button>
    <button class="danger" id="stop">STOP</button>
  </div>
</header>

<main>
  <canvas id="game" width="520" height="860"></canvas>
</main>

<footer>
  <div class="row">
    <span class="pill">操作: <b>スマホを振る/動かす</b></span>
    <span class="pill">TAP: タイミングで振る</span>
    <span class="pill">HOLD: 開始で振って掴む → <b>動かし続けて</b>維持</span>
    <span class="pill">判定: <span class="mono">PERFECT / GREAT / GOOD / MISS</span></span>
  </div>
  <div style="margin-top:10px">
    iOSは「モーション許可」→「START」の順で。PCではスペースキーでTAP判定できます（HOLDは疑似的に連打で維持）。
  </div>
</footer>

<script>
(() => {
  // -----------------------------
  // Canvas setup
  // -----------------------------
  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");

  // -----------------------------
  // Audio (simple beep)
  // -----------------------------
  let audioCtx = null;
  function ensureAudio() {
    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    if (audioCtx.state === "suspended") audioCtx.resume();
  }
  function beep(freq = 880, dur = 0.05, gain = 0.06) {
    if (!audioCtx) return;
    const t0 = audioCtx.currentTime;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.frequency.value = freq;
    o.type = "square";
    g.gain.setValueAtTime(gain, t0);
    g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
    o.connect(g).connect(audioCtx.destination);
    o.start(t0);
    o.stop(t0 + dur);
  }

  // -----------------------------
  // Difficulty presets
  //  - shakeThreshold: 軽く振るだけで反応するように下げた
  //  - hold率や長さも難易度で変える
  // -----------------------------
  const DIFF = {
    easy:   { bpm: 92,  lengthBeats: 64,  spawnJitter: 0.08, overlapRate: 0.18, noteSpeed: 430, shakeThreshold: 6.0,  holdRate: 0.14, holdBeatsMin: 2, holdBeatsMax: 4 },
    normal: { bpm: 112, lengthBeats: 80,  spawnJitter: 0.06, overlapRate: 0.26, noteSpeed: 520, shakeThreshold: 5.0,  holdRate: 0.18, holdBeatsMin: 2, holdBeatsMax: 5 },
    hard:   { bpm: 134, lengthBeats: 96,  spawnJitter: 0.05, overlapRate: 0.38, noteSpeed: 640, shakeThreshold: 4.2,  holdRate: 0.22, holdBeatsMin: 3, holdBeatsMax: 7 },
  };

  // -----------------------------
  // Game state
  // Notes:
  //  type: "tap" | "hold"
  //  t: 判定ライン到達時刻（開始）
  //  tEnd: hold終了時刻（holdのみ）
  //  judged / hit / holding / completed
  // -----------------------------
  let running = false;
  let startTime = 0;
  let notes = [];
  let score = 0;
  let combo = 0;
  let maxCombo = 0;
  let counts = { perfect:0, great:0, good:0, miss:0, holdOk:0, holdFail:0 };

  let currentDiffKey = "normal";
  let judgeText = "";
  let judgeTextUntil = 0;

  // input
  let lastShakeAtMs = -999;
  let shakeCooldownMs = 80;     // 140 -> 80（連打しやすく）
  let lastMag = 0;

  // hold energy model
  //  - motionでenergyを足す
  //  - 毎フレーム減衰
  //  - 一定時間energy低い状態が続いたら失敗
  let holdEnergy = 0;
  let holdLowSinceMs = null;

  const HOLD = {
    // これを上げるほど「動かし続けないと維持できない」
    minEnergyToSustain: 0.35,
    // energyが足りない状態がこの時間続くと失敗
    failAfterMs: 260,
    // 減衰（秒あたり）
    decayPerSec: 0.85,
    // motionイベントでdeltaがこの値を超えたらenergy加算（しきい値より低く設定して"軽い動き"も拾う）
    sustainDeltaFactor: 0.60,
    // 加算倍率
    addGain: 0.14,
  };

  // Layout
  const W = canvas.width;
  const H = canvas.height;
  const laneX = W * 0.5;
  const judgeY = H * 0.78;

  // Judgment windows (seconds)
  const WINDOWS = [
    { name: "PERFECT", dt: 0.060, pts: 100, key: "perfect", freq: 1200 },
    { name: "GREAT",   dt: 0.100, pts: 70,  key: "great",   freq: 980  },
    { name: "GOOD",    dt: 0.140, pts: 40,  key: "good",    freq: 740  },
  ];

  function showJudge(text, pts=0) {
    judgeText = pts > 0 ? `${text} +${pts}` : text;
    judgeTextUntil = performance.now() + 520;
  }

  function nowSec() {
    return (performance.now() - startTime) / 1000;
  }

  function noteY(noteTime, t, speedPxPerSec) {
    const dt = noteTime - t;
    return judgeY - dt * speedPxPerSec;
  }

  // -----------------------------
  // Chart generation (tap + hold + overlaps)
  // -----------------------------
  function buildChart(diffKey) {
    const p = DIFF[diffKey];
    const beatSec = 60 / p.bpm;

    const arr = [];
    for (let i = 0; i < p.lengthBeats; i++) {
      const baseT = i * beatSec;

      // tap base
      arr.push({ type: "tap", t: baseT });

      // off-beat tap
      if (Math.random() < 0.32) {
        arr.push({ type: "tap", t: baseT + 0.5 * beatSec });
      }

      // occasional overlaps (stack)
      if (Math.random() < p.overlapRate) {
        const extra = (Math.random() < 0.35) ? 2 : 1;
        for (let k = 0; k < extra; k++) {
          const jitter = (Math.random() * 2 - 1) * p.spawnJitter * beatSec;
          arr.push({ type: "tap", t: baseT + jitter });
        }
      }

      // hold notes
      // holdは「次の数拍を占有する」ため、生成しすぎないように率で制御
      if (Math.random() < p.holdRate) {
        const beats = p.holdBeatsMin + Math.floor(Math.random() * (p.holdBeatsMax - p.holdBeatsMin + 1));
        const tEnd = baseT + beats * beatSec;
        arr.push({ type: "hold", t: baseT + 0.25 * beatSec, tEnd });
      }
    }

    arr.sort((a,b)=>a.t-b.t);
    const leadIn = 1.8;

    notes = arr.map(n => ({
      type: n.type,
      t: n.t + leadIn,
      tEnd: (n.type === "hold" ? (n.tEnd + leadIn) : null),
      judged: false,
      hit: false,
      holding: false,
      completed: false
    }));

    score = 0; combo = 0; maxCombo = 0;
    counts = { perfect:0, great:0, good:0, miss:0, holdOk:0, holdFail:0 };
    judgeText = "";
    judgeTextUntil = 0;

    holdEnergy = 0;
    holdLowSinceMs = null;
  }

  // -----------------------------
  // Tap judge (on shake)
  // -----------------------------
  function judgeTapAt(actionTimeSec) {
    if (!running) return;

    // collect hittable tap notes within GOOD window
    const hittable = [];
    for (const n of notes) {
      if (n.judged) continue;
      if (n.type !== "tap") continue;
      const dt = Math.abs(actionTimeSec - n.t);
      if (dt <= WINDOWS[WINDOWS.length - 1].dt) hittable.push({ n, dt });
    }

    // also allow starting hold
    const holdStartable = [];
    for (const n of notes) {
      if (n.judged) continue;
      if (n.type !== "hold") continue;
      if (n.holding || n.completed) continue;
      const dt = Math.abs(actionTimeSec - n.t);
      if (dt <= WINDOWS[WINDOWS.length - 1].dt) holdStartable.push({ n, dt });
    }

    if (hittable.length === 0 && holdStartable.length === 0) {
      showJudge("EMPTY", 0);
      beep(220, 0.04, 0.04);
      return;
    }

    // tap notes: grade each
    let best = null;
    for (const h of hittable) {
      const { n, dt } = h;
      let wHit = null;
      for (const w of WINDOWS) { if (dt <= w.dt) { wHit = w; break; } }
      if (!wHit) continue;

      n.hit = true;
      n.judged = true;
      score += wHit.pts;
      combo += 1;
      maxCombo = Math.max(maxCombo, combo);
      counts[wHit.key] += 1;
      beep(wHit.freq, 0.05, 0.06);

      if (!best || wHit.pts > best.pts) best = wHit;
    }

    // start hold: (1振りで複数hold開始も可)
    // hold開始は「tapと同時」でも問題ない設計
    for (const h of holdStartable) {
      const { n, dt } = h;
      let wHit = null;
      for (const w of WINDOWS) { if (dt <= w.dt) { wHit = w; break; } }
      if (!wHit) continue;

      n.holding = true;
      n.hit = true; // started
      // 開始点はスコア軽め、維持完了で加点
      score += Math.floor(wHit.pts * 0.35);
      combo += 1;
      maxCombo = Math.max(maxCombo, combo);
      beep(860, 0.05, 0.06);

      if (!best || wHit.pts > best.pts) best = wHit;
      showJudge("HOLD START", 0);

      // hold開始直後に少しenergyを入れて、取りこぼしを減らす
      holdEnergy = Math.min(1, holdEnergy + 0.25);
      holdLowSinceMs = null;
    }

    if (best) showJudge(best.name, best.pts);
  }

  // -----------------------------
  // Miss processing & Hold updates
  // -----------------------------
  function processMissesAndHold(t, dtSec) {
    const missAfter = WINDOWS[WINDOWS.length - 1].dt;

    // decay hold energy
    holdEnergy = Math.max(0, holdEnergy - HOLD.decayPerSec * dtSec);

    // if any hold is active, check sustain
    const nowMs = performance.now();
    const anyHolding = notes.some(n => n.type === "hold" && n.holding && !n.completed);

    if (anyHolding) {
      if (holdEnergy < HOLD.minEnergyToSustain) {
        if (holdLowSinceMs == null) holdLowSinceMs = nowMs;
        if (nowMs - holdLowSinceMs > HOLD.failAfterMs) {
          // fail all currently holding notes
          for (const n of notes) {
            if (n.type === "hold" && n.holding && !n.completed && !n.judged) {
              n.holding = false;
              n.judged = true;
              n.hit = false;
              counts.holdFail += 1;
              counts.miss += 1;
            }
          }
          combo = 0;
          showJudge("HOLD FAIL", 0);
          beep(180, 0.06, 0.07);
          holdLowSinceMs = null;
        }
      } else {
        holdLowSinceMs = null;
      }
    } else {
      holdLowSinceMs = null;
    }

    // complete holds
    for (const n of notes) {
      if (n.type !== "hold") continue;
      if (n.judged) continue;

      // if started and time passed end -> success
      if (n.holding && t >= n.tEnd) {
        n.completed = true;
        n.holding = false;
        n.judged = true;
        n.hit = true;
        counts.holdOk += 1;

        // finish bonus
        score += 120;
        combo += 1;
        maxCombo = Math.max(maxCombo, combo);
        showJudge("HOLD OK +120", 0);
        beep(1300, 0.06, 0.07);
      }

      // if not started and passed start window -> miss
      if (!n.holding && !n.completed && (t - n.t) > missAfter) {
        n.judged = true;
        n.hit = false;
        counts.miss += 1;
        combo = 0;
        showJudge("MISS", 0);
      }
    }

    // tap misses
    for (const n of notes) {
      if (n.type !== "tap") continue;
      if (n.judged) continue;
      if (t - n.t > missAfter) {
        n.judged = true;
        n.hit = false;
        counts.miss += 1;
        combo = 0;
        showJudge("MISS", 0);
      }
    }
  }

  // -----------------------------
  // Rendering
  // -----------------------------
  function draw(t) {
    const p = DIFF[currentDiffKey];
    ctx.clearRect(0, 0, W, H);

    // background grid
    ctx.save();
    ctx.globalAlpha = 0.18;
    ctx.strokeStyle = "#9fb6d9";
    for (let y=40; y<H; y+=60) {
      ctx.beginPath();
      ctx.moveTo(20, y);
      ctx.lineTo(W-20, y);
      ctx.stroke();
    }
    ctx.restore();

    // judge line + windows
    ctx.save();
    ctx.lineWidth = 3;
    ctx.strokeStyle = "rgba(47,129,247,0.8)";
    ctx.beginPath();
    ctx.moveTo(40, judgeY);
    ctx.lineTo(W-40, judgeY);
    ctx.stroke();

    ctx.globalAlpha = 0.10;
    ctx.fillStyle = "#2f81f7";
    const pxGood = WINDOWS[2].dt * p.noteSpeed;
    const pxGreat = WINDOWS[1].dt * p.noteSpeed;
    const pxPerfect = WINDOWS[0].dt * p.noteSpeed;
    ctx.fillRect(40, judgeY - pxGood, W-80, pxGood*2);
    ctx.globalAlpha = 0.14;
    ctx.fillRect(40, judgeY - pxGreat, W-80, pxGreat*2);
    ctx.globalAlpha = 0.18;
    ctx.fillRect(40, judgeY - pxPerfect, W-80, pxPerfect*2);
    ctx.restore();

    const visibleTop = -120, visibleBottom = H + 120;

    // draw holds (as vertical capsule)
    for (const n of notes) {
      if (n.type !== "hold") continue;
      const y0 = noteY(n.t, t, p.noteSpeed);
      const y1 = noteY(n.tEnd, t, p.noteSpeed);

      // if completely out of view, skip
      const top = Math.min(y0, y1), bottom = Math.max(y0, y1);
      if (bottom < visibleTop || top > visibleBottom) continue;

      // body
      const x = laneX;
      const w = 18;
      const r = 10;

      ctx.save();
      const active = n.holding && !n.completed && !n.judged;
      const done = n.completed || (n.judged && n.hit);
      const failed = n.judged && !n.hit;

      let fill = "rgba(230,237,243,0.18)";
      let stroke = "rgba(47,129,247,0.55)";
      if (active) { fill = "rgba(47,129,247,0.22)"; stroke = "rgba(47,129,247,0.90)"; }
      if (done)   { fill = "rgba(46,160,67,0.18)"; stroke = "rgba(46,160,67,0.90)"; }
      if (failed) { fill = "rgba(248,81,73,0.12)"; stroke = "rgba(248,81,73,0.70)"; }

      ctx.fillStyle = fill;
      ctx.strokeStyle = stroke;
      ctx.lineWidth = 2;

      // rounded rect
      const yTop = Math.min(y0, y1);
      const h = Math.abs(y1 - y0);
      roundRect(ctx, x - w/2, yTop, w, h, r);
      ctx.fill();
      ctx.stroke();

      // head marker (start)
      ctx.beginPath();
      ctx.fillStyle = active ? "rgba(47,129,247,0.95)" : "rgba(230,237,243,0.85)";
      ctx.arc(x, y0, 14, 0, Math.PI*2);
      ctx.fill();

      // tail marker (end)
      ctx.beginPath();
      ctx.fillStyle = "rgba(230,237,243,0.30)";
      ctx.arc(x, y1, 9, 0, Math.PI*2);
      ctx.fill();

      ctx.restore();
    }

    // draw tap stacks (overlaps)
    const stacks = [];
    const tol = 0.012;
    for (const n of notes) {
      if (n.type !== "tap") continue;
      const y = noteY(n.t, t, p.noteSpeed);
      if (y < visibleTop || y > visibleBottom) continue;
      if (n.judged && y > judgeY + 20) continue;

      let found = false;
      for (const s of stacks) {
        if (Math.abs(s.t - n.t) < tol) { s.items.push({n,y}); found = true; break; }
      }
      if (!found) stacks.push({ t: n.t, items: [{n,y}] });
    }

    for (const s of stacks) {
      const items = s.items;
      items.sort((a,b)=>a.y-b.y);
      for (let i=0; i<items.length; i++) {
        const { n, y } = items[i];
        const offset = (i - (items.length-1)/2) * 14;
        const r = 14;

        ctx.beginPath();
        ctx.fillStyle = n.judged ? (n.hit ? "rgba(46,160,67,0.85)" : "rgba(248,81,73,0.55)") : "rgba(230,237,243,0.85)";
        ctx.strokeStyle = "rgba(0,0,0,0.35)";
        ctx.lineWidth = 2;
        ctx.arc(laneX + offset, y, r, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();

        if (!n.judged) {
          ctx.beginPath();
          ctx.strokeStyle = "rgba(47,129,247,0.7)";
          ctx.lineWidth = 2;
          ctx.arc(laneX + offset, y, r-5, 0, Math.PI * 2);
          ctx.stroke();
        }
      }
    }

    // hold energy bar (debug)
    ctx.save();
    const barW = 160, barH = 10;
    const bx = 18, by = H - 60;
    ctx.fillStyle = "rgba(255,255,255,0.10)";
    ctx.fillRect(bx, by, barW, barH);
    ctx.fillStyle = "rgba(47,129,247,0.85)";
    ctx.fillRect(bx, by, barW * Math.max(0, Math.min(1, holdEnergy)), barH);
    ctx.fillStyle = "rgba(230,237,243,0.70)";
    ctx.font = "600 12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
    ctx.fillText(`HOLD ENERGY`, bx, by - 6);
    ctx.restore();

    // HUD
    ctx.save();
    ctx.fillStyle = "rgba(230,237,243,0.92)";
    ctx.font = "700 22px system-ui, -apple-system, Segoe UI, Roboto, sans-serif";
    ctx.fillText(`SCORE  ${score}`, 18, 36);

    ctx.font = "600 16px system-ui, -apple-system, Segoe UI, Roboto, sans-serif";
    ctx.fillStyle = "rgba(230,237,243,0.75)";
    ctx.fillText(`COMBO  ${combo}   (MAX ${maxCombo})`, 18, 60);

    ctx.fillText(
      `P:${counts.perfect}  G:${counts.great}  O:${counts.good}  M:${counts.miss}  H_OK:${counts.holdOk}  H_NG:${counts.holdFail}`,
      18, 84
    );

    if (performance.now() < judgeTextUntil) {
      ctx.fillStyle = "rgba(255,255,255,0.92)";
      ctx.font = "800 30px system-ui, -apple-system, Segoe UI, Roboto, sans-serif";
      const m = ctx.measureText(judgeText);
      ctx.fillText(judgeText, (W - m.width) / 2, judgeY - 90);
    }

    ctx.fillStyle = "rgba(230,237,243,0.65)";
    ctx.font = "600 14px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
    ctx.fillText(
      `DIFF: ${currentDiffKey.toUpperCase()}   TH: ${DIFF[currentDiffKey].shakeThreshold.toFixed(1)}   COOL: ${shakeCooldownMs}ms`,
      18, H - 24
    );
    ctx.restore();
  }

  function roundRect(ctx, x, y, w, h, r) {
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x + rr, y);
    ctx.arcTo(x + w, y, x + w, y + h, rr);
    ctx.arcTo(x + w, y + h, x, y + h, rr);
    ctx.arcTo(x, y + h, x, y, rr);
    ctx.arcTo(x, y, x + w, y, rr);
    ctx.closePath();
  }

  // -----------------------------
  // Main loop
  // -----------------------------
  let lastFrameMs = 0;
  function frame(ts) {
    if (!running) return;
    const t = nowSec();
    const nowMs = performance.now();
    const dtSec = lastFrameMs ? ((nowMs - lastFrameMs) / 1000) : (1/60);
    lastFrameMs = nowMs;

    processMissesAndHold(t, dtSec);
    draw(t);

    const lastNote = notes[notes.length - 1];
    if (lastNote) {
      const endT = (lastNote.type === "hold" ? lastNote.tEnd : lastNote.t);
      if (t - endT > 1.2) {
        stopGame();
        showJudge("FINISH", 0);
        return;
      }
    }

    requestAnimationFrame(frame);
  }

  function startGame() {
    currentDiffKey = document.getElementById("difficulty").value;
    buildChart(currentDiffKey);
    ensureAudio();

    running = true;
    startTime = performance.now();
    lastFrameMs = 0;
    lastShakeAtMs = -999;
    lastMag = 0;
    holdEnergy = 0;
    holdLowSinceMs = null;

    showJudge("READY", 0);

    // simple metronome
    const p = DIFF[currentDiffKey];
    const beatMs = 60000 / p.bpm;
    let metCount = 0;
    const metId = setInterval(() => {
      if (!running) { clearInterval(metId); return; }
      const f = (metCount % 4 === 0) ? 520 : 420;
      beep(f, 0.03, 0.04);
      metCount++;
    }, beatMs);

    requestAnimationFrame(frame);
  }

  function stopGame() {
    running = false;
  }

  // -----------------------------
  // Shake / motion handling
  //  - 軽い振りで反応：thresholdを下げる + delta倍率
  //  - hold維持：thresholdより低いdeltaでもenergy加算
  // -----------------------------
  function onMotion(e) {
    if (!running) return;
    const acc = e.accelerationIncludingGravity || e.acceleration;
    if (!acc) return;

    const ax = acc.x || 0, ay = acc.y || 0, az = acc.z || 0;
    const mag = Math.sqrt(ax*ax + ay*ay + az*az);

    // 以前との差（高域っぽくする）
    let delta = Math.abs(mag - lastMag);
    lastMag = mag;

    // 小さな動きを拾いやすく（体感調整）
    delta *= 1.6;

    const threshold = DIFF[currentDiffKey].shakeThreshold;

    // hold維持用：thresholdの一部でもenergy追加
    if (delta > threshold * HOLD.sustainDeltaFactor) {
      holdEnergy = Math.min(1, holdEnergy + HOLD.addGain * (delta / threshold));
    }

    // tap/hold開始：threshold超えで1入力（クールダウンあり）
    const nowMs = performance.now();
    if (delta > threshold && (nowMs - lastShakeAtMs) > shakeCooldownMs) {
      lastShakeAtMs = nowMs;
      judgeTapAt(nowSec());
    }
  }

  // desktop fallback: Space key
  window.addEventListener("keydown", (e) => {
    if (e.code === "Space") {
      e.preventDefault();
      if (!running) return;

      // PCはモーションが無いので、Spaceでenergyも入れる（hold維持テスト用）
      holdEnergy = Math.min(1, holdEnergy + 0.22);

      const nowMs = performance.now();
      if ((nowMs - lastShakeAtMs) > shakeCooldownMs) {
        lastShakeAtMs = nowMs;
        judgeTapAt(nowSec());
      }
    }
  }, { passive: false });

  async function requestMotionPermission() {
    try {
      if (typeof DeviceMotionEvent === "undefined") {
        alert("この端末/ブラウザはDeviceMotionに対応していない可能性があります。");
        return;
      }
      if (typeof DeviceMotionEvent.requestPermission === "function") {
        const res = await DeviceMotionEvent.requestPermission();
        if (res !== "granted") {
          alert("モーション許可が拒否されました。設定から許可してください。");
          return;
        }
      }
      window.addEventListener("devicemotion", onMotion, { passive: true });
      alert("モーションを有効化しました。STARTで開始できます。");
    } catch (err) {
      console.error(err);
      alert("モーション許可の取得に失敗しました。");
    }
  }

  // UI wiring
  document.getElementById("start").addEventListener("click", () => {
    if (running) return;
    startGame();
  });
  document.getElementById("stop").addEventListener("click", () => stopGame());
  document.getElementById("motionPerm").addEventListener("click", () => requestMotionPermission());

  // Android等は許可不要の場合がある
  if (typeof DeviceMotionEvent !== "undefined" && typeof DeviceMotionEvent.requestPermission !== "function") {
    window.addEventListener("devicemotion", onMotion, { passive: true });
  }

  // initial render
  draw(0);
  window.__ShakeRhythm = { startGame, stopGame };
})();
</script>
</body>
</html>