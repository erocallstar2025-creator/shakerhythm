<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Shake Rhythm (TAP Only)</title>
  <style>
    :root { color-scheme: dark; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, "Hiragino Kaku Gothic ProN", "Noto Sans JP", sans-serif;
      background: #0b0f14;
      color: #e6edf3;
      display: flex;
      min-height: 100vh;
      flex-direction: column;
      overflow: hidden;
    }
    header {
      padding: 12px 14px;
      border-bottom: 1px solid rgba(255,255,255,0.08);
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
    }
    header .title { font-weight: 700; letter-spacing: 0.2px; }
    header .controls {
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
      margin-left: auto;
    }
    select, button {
      background: rgba(255,255,255,0.08);
      color: #e6edf3;
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 10px;
      padding: 10px 12px;
      font-size: 14px;
      outline: none;
    }
    button { cursor: pointer; }
    button.primary {
      background: #2f81f7;
      border-color: rgba(47,129,247,0.6);
      color: #07121f;
      font-weight: 700;
    }
    button.danger {
      background: rgba(248,81,73,0.15);
      border-color: rgba(248,81,73,0.4);
      color: #ffb4b0;
    }
    main {
      flex: 1;
      display: grid;
      place-items: center;
      padding: 10px;
    }
    canvas {
      width: min(94vw, 520px);
      height: min(78vh, 860px);
      background: radial-gradient(1200px 900px at 50% 20%, rgba(47,129,247,0.08), transparent 60%),
                  linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02));
      border: 1px solid rgba(255,255,255,0.10);
      border-radius: 16px;
      box-shadow: 0 12px 40px rgba(0,0,0,0.45);
      touch-action: none;
    }
    footer {
      padding: 10px 14px 14px;
      border-top: 1px solid rgba(255,255,255,0.08);
      font-size: 12px;
      color: rgba(230,237,243,0.75);
      line-height: 1.45;
    }
    .row { display: flex; gap: 12px; flex-wrap: wrap; align-items: center; }
    .pill {
      display: inline-flex; gap: 8px; align-items: center;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(0,0,0,0.18);
      padding: 8px 10px;
      border-radius: 999px;
      font-size: 12px;
      color: rgba(230,237,243,0.9);
    }
    .mono { font-variant-numeric: tabular-nums; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
  </style>
</head>

<body>
<header>
  <div class="title">Shake Rhythm — TAPのみ</div>
  <div class="controls">
    <select id="difficulty">
      <option value="easy">EASY（ゆっくり）</option>
      <option value="normal" selected>NORMAL（標準）</option>
      <option value="hard">HARD（速い）</option>
    </select>
    <button id="motionPerm">モーション許可</button>
    <button class="primary" id="start">START</button>
    <button class="danger" id="stop">STOP</button>
  </div>
</header>

<main>
  <canvas id="game" width="520" height="860"></canvas>
</main>

<footer>
  <div class="row">
    <span class="pill">操作: <b>スマホを軽く振る</b>（タイミングで判定）</span>
    <span class="pill">重なり: 近いノーツを<b>一度の振りでまとめて判定</b></span>
    <span class="pill">判定: <span class="mono">PERFECT / GREAT / GOOD / MISS</span></span>
  </div>
  <div style="margin-top:10px">
    iOSは「モーション許可」→「START」の順。PCではスペースキーでも叩けます。
  </div>
</footer>

<script>
(() => {
  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");
  const W = canvas.width;
  const H = canvas.height;

  const laneX = W * 0.5;
  const judgeY = H * 0.78;

  let audioCtx = null;
  function ensureAudio() {
    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    if (audioCtx.state === "suspended") audioCtx.resume();
  }

  function beep(freq = 880, dur = 0.05, gain = 0.06) {
    if (!audioCtx) return;
    const t0 = audioCtx.currentTime;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.frequency.value = freq;
    o.type = "square";
    g.gain.setValueAtTime(gain, t0);
    g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
    o.connect(g).connect(audioCtx.destination);
    o.start(t0);
    o.stop(t0 + dur);
  }

  const DIFF = {
    easy:   { bpm: 92,  lengthBeats: 64, spawnJitter: 0.08, overlapRate: 0.22, noteSpeed: 430, shakeThreshold: 6.0 },
    normal: { bpm: 112, lengthBeats: 80, spawnJitter: 0.06, overlapRate: 0.32, noteSpeed: 520, shakeThreshold: 5.0 },
    hard:   { bpm: 134, lengthBeats: 96, spawnJitter: 0.05, overlapRate: 0.45, noteSpeed: 640, shakeThreshold: 4.2 },
  };

  const WINDOWS = [
    { name: "PERFECT", dt: 0.060, pts: 100, key: "perfect", freq: 1200 },
    { name: "GREAT",   dt: 0.100, pts: 70,  key: "great",   freq: 980  },
    { name: "GOOD",    dt: 0.140, pts: 40,  key: "good",    freq: 740  },
  ];

  let running = false;
  let startTime = 0;
  let notes = [];
  let score = 0;
  let combo = 0;
  let maxCombo = 0;
  let counts = { perfect:0, great:0, good:0, miss:0 };
  let currentDiffKey = "normal";
  let judgeText = "";
  let judgeTextUntil = 0;

  let lastShakeAtMs = -999;
  let shakeCooldownMs = 120; 

  function nowSec() { return (performance.now() - startTime) / 1000; }
  function showJudge(text, pts=0) {
    judgeText = pts > 0 ? `${text} +${pts}` : text;
    judgeTextUntil = performance.now() + 520;
  }
  function noteY(noteTime, t, speedPxPerSec) {
    const dt = noteTime - t;
    return judgeY - dt * speedPxPerSec;
  }

  function buildChart(diffKey) {
    const p = DIFF[diffKey];
    const beatSec = 60 / p.bpm;
    const arr = [];
    for (let i = 0; i < p.lengthBeats; i++) {
      const baseT = i * beatSec;
      arr.push({ t: baseT });
      if (Math.random() < 0.35) arr.push({ t: baseT + 0.5 * beatSec });
      if (Math.random() < p.overlapRate) {
        const extra = (Math.random() < 0.35) ? 2 : 1;
        for (let k = 0; k < extra; k++) {
          const jitter = (Math.random() * 2 - 1) * p.spawnJitter * beatSec;
          arr.push({ t: baseT + jitter });
        }
      }
    }
    arr.sort((a,b)=>a.t-b.t);
    const leadIn = 2.0;
    notes = arr.map(n => ({ t: n.t + leadIn, judged: false, hit: false }));
    
    score = 0; combo = 0; maxCombo = 0;
    counts = { perfect:0, great:0, good:0, miss:0 };
    judgeText = "";
  }

  function judgeAt(actionTimeSec) {
    if (!running) return;
    const goodWin = WINDOWS[WINDOWS.length - 1].dt;
    const hittable = [];
    for (const n of notes) {
      if (n.judged) continue;
      const dt = Math.abs(actionTimeSec - n.t);
      if (dt <= goodWin) hittable.push({ n, dt });
    }

    if (hittable.length === 0) {
      showJudge("EMPTY", 0);
      beep(220, 0.04, 0.04);
      return;
    }

    let best = null;
    for (const h of hittable) {
      const { n, dt } = h;
      let hitGrade = null;
      for (const w of WINDOWS) {
        if (dt <= w.dt) { hitGrade = w; break; }
      }
      if (!hitGrade) continue;
      n.judged = true;
      n.hit = true;
      score += hitGrade.pts;
      combo += 1;
      maxCombo = Math.max(maxCombo, combo);
      counts[hitGrade.key] += 1;
      beep(hitGrade.freq, 0.05, 0.06);
      if (!best || hitGrade.pts > best.pts) best = hitGrade;
    }
    if (best) showJudge(best.name, best.pts);
  }

  function processMisses(t) {
    const missAfter = WINDOWS[WINDOWS.length - 1].dt;
    for (const n of notes) {
      if (!n.judged && (t - n.t > missAfter)) {
        n.judged = true;
        n.hit = false;
        counts.miss += 1;
        combo = 0;
        showJudge("MISS", 0);
      }
    }
  }

  function draw(t) {
    const p = DIFF[currentDiffKey];
    ctx.clearRect(0, 0, W, H);

    // 背景グリッド
    ctx.save();
    ctx.globalAlpha = 0.12;
    ctx.strokeStyle = "#9fb6d9";
    for (let y=0; y<H; y+=60) {
      ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(W, y); ctx.stroke();
    }
    ctx.restore();

    // 判定ライン
    ctx.save();
    ctx.lineWidth = 3;
    ctx.strokeStyle = "rgba(47,129,247,0.8)";
    ctx.beginPath(); ctx.moveTo(40, judgeY); ctx.lineTo(W-40, judgeY); ctx.stroke();
    ctx.restore();

    // ノーツ描画
    for (const n of notes) {
      const y = noteY(n.t, t, p.noteSpeed);
      if (y < -50 || y > H + 50) continue;
      if (n.judged && y > judgeY + 50) continue;

      ctx.beginPath();
      ctx.fillStyle = n.judged ? (n.hit ? "#2ea043" : "#f85149") : "#e6edf3";
      ctx.globalAlpha = n.judged ? 0.3 : 0.9;
      ctx.arc(laneX, y, 16, 0, Math.PI * 2);
      ctx.fill();
    }

    // HUD
    ctx.save();
    ctx.fillStyle = "#e6edf3";
    ctx.font = "bold 24px sans-serif";
    ctx.fillText(`SCORE: ${score}`, 20, 40);
    ctx.font = "16px monospace";
    ctx.fillText(`COMBO: ${combo} / MAX: ${maxCombo}`, 20, 70);
    if (performance.now() < judgeTextUntil) {
      ctx.font = "bold 40px sans-serif";
      ctx.textAlign = "center";
      ctx.fillText(judgeText, W/2, judgeY - 100);
    }
    ctx.restore();
  }

  function frame() {
    if (!running) return;
    const t = nowSec();
    processMisses(t);
    draw(t);

    const lastNote = notes[notes.length - 1];
    if (lastNote && (t - lastNote.t) > 1.5) {
      stopGame();
      alert(`Finish! Score: ${score}\nMax Combo: ${maxCombo}`);
    } else {
      requestAnimationFrame(frame);
    }
  }

  function startGame() {
    ensureAudio();
    currentDiffKey = document.getElementById("difficulty").value;
    buildChart(currentDiffKey);
    running = true;
    startTime = performance.now();
    requestAnimationFrame(frame);
  }

  function stopGame() {
    running = false;
    ctx.clearRect(0,0,W,H);
  }

  // -----------------------------
  // Input (Motion & Key)
  // -----------------------------
  window.addEventListener("devicemotion", (e) => {
    if (!running) return;
    const acc = e.accelerationIncludingGravity || e.acceleration;
    if (!acc) return;

    const mag = Math.sqrt(acc.x**2 + acc.y**2 + acc.z**2);
    const diff = Math.abs(mag - 9.8); // 重力加速度を差し引いた変化量
    const thresh = DIFF[currentDiffKey].shakeThreshold;

    const now = performance.now();
    if (diff > thresh && (now - lastShakeAtMs > shakeCooldownMs)) {
      lastShakeAtMs = now;
      judgeAt(nowSec());
    }
  });

  window.addEventListener("keydown", (e) => {
    if (e.code === "Space") {
      e.preventDefault();
      ensureAudio();
      if (running) judgeAt(nowSec());
    }
  });

  document.getElementById("start").onclick = startGame;
  document.getElementById("stop").onclick = stopGame;

  document.getElementById("motionPerm").onclick = async () => {
    if (typeof DeviceMotionEvent.requestPermission === 'function') {
      const res = await DeviceMotionEvent.requestPermission();
      if (res === 'granted') alert("モーション許可されました");
    } else {
      alert("このデバイスでは許可設定は不要か、非対応です。");
    }
  };

  // 初期描画
  draw(0);
})();
</script>
</body>
</html>